## 1. Реализация связного списка и сравнение его производительности с LinkedList.

### Постановка задачи

будет интересно сравнить производительность, написанной вами коллекции, с Java реализацией.
Для этого необходимо создать объекты MyLinkedList и java.util.LinkedList. 
Используя System.nanoTime оценить примерно время выполнения основных 
операций – добавления, поиска, удаления элемента.  

### Требования

Количество элементов в коллекции подбираем самостоятельно. 
Возьмите для начала 10000 элементов. 
При необходимости количество элементов можно варьировать на ваше усмотрение.

### Решение и полученные результаты

Количество тестовых данных равно 100000, тип объектов - int.
Каждый из методов запускался 20 раз, затем бралось среднее значение.
Данные в таблицах приведены в секундах.

| Collection  | add in the end | add in the middle | remove from end | 
| ---------- | -------------- | ----------------- | --------------- |
| MyLinkedList  | 0.0045767761 | 10.7093663021 | 16.158329632050002 | 
| LinkedList | 0.0023388407999999994 | 9.86732073225 | 0.0016852335 |

### Вывод

Моя реализация связного списка MyLinkedList слегка отстаёт в производительности от связного списка из java.util
в добавлении, а в удалении с конца отстает сильно, поскольку реализация наивна и выполнена лишь для получения
корректных результатов, а не для меньшего времени выполнения.

## 2. Сравнительный анализ производительности основных Java коллекций.

### Постановка задачи
Написать тестовый класс, измеряющий с помощью System.nanoTime() время выполнения основных операций – добавление, вставка, удаление элементов

1. Сравнить производительность ArrayList и LinkedList для основных операций
2. Сравнить производительность HashSet, LinkedHashSet, TreeSet для основных операций
3. Сравнить производительность HashMap, LinkedHashMap, TreeMap

### Требования
Размер, тип, количество тестовых данных выбираем самостоятельно. Это уже ваше творчество. Но количество объектов в коллекции не менее 10000, а при необходимости увеличить до 100000.
В выводе необходимо указать в каких случаях удобно использовать ту или иную коллекцию (для каждого из пунктов a,b,c) 

### Решение и полученные результаты

Количество тестовых данных равно 100000, тип объектов - int. 
Каждый из методов запускался 20 раз, затем бралось среднее значение. 
Данные в таблице приведены в секундах. 

1. Сравнение ArrayList и LinkedList

| Collection  | add in the end | add in the middle | remove from end | 
| ---------- | -------------- | ----------------- | --------------- |
| ArrayList  | 0.003258899500000001 | 0.47787993374999993 | 9.629139999999999E-4 |
| LinkedList | 0.0023388407999999994 | 9.86732073225 | 0.0016852335 |

2. Сравнение HashSet, LinkedHashSet и TreeSet

| Collection  | add | remove | 
| ---------- | -------------- | --------------- |
| HashSet  | 0.006126607549999999 | 0.00785445185 |
| LinkedHashSet | 0.0063080051 | 0.005592977149999999 |
| TreeSet | 0.02186874835 | 0.01682749895 |

3. Сравнение HashMap, LinkedHashMap и TreeMap

| Collection  | add | remove | 
| ---------- | -------------- | --------------- |
| HashMap  | 0.00869312345 | 0.0040778119 |
| LinkedHashMap | 0.008554334850000001 | 0.0069270771999999994 |
| TreeMap | 0.02418163165 | 0.014756663150000002 |

### Выводы

1. В сравнении с LinkedList, ArrayList более подходит для добавления элементов, нежели для их удаления. 
   У LinkedList удаление элементов с конца происходит намного быстрее.
   
2. Наименьшую производительность показал TreeSet, он проигрывает и во вставке элементов и по удалению элементов.
   HashSet и LinkedHashSet очень похожи в плане производительности, однако удаление элементов у LinkedHashSet быстрее.
   
3. Наименьшая производительность достигнута TreeMap. HashMap и LinkedHashMap одинаковы по добавлению элементов, однако у 
   HashMap удаление с конца происходит быстрее.